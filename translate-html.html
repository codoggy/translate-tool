<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Translate Tool</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; }
    .animate-bounce-1 { animation: bounce 1s infinite; animation-delay: 0ms; }
    .animate-bounce-2 { animation: bounce 1s infinite; animation-delay: 150ms; }
    .animate-bounce-3 { animation: bounce 1s infinite; animation-delay: 300ms; }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-4px); }
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .animate-spin { animation: spin 1s linear infinite; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    // Icons as simple SVG components
    const Icon = ({ d, className = "w-5 h-5" }) => (
      <svg className={className} fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" d={d} />
      </svg>
    );
    const Icons = {
      Languages: (p) => <Icon {...p} d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129" />,
      Settings: (p) => <Icon {...p} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z M15 12a3 3 0 11-6 0 3 3 0 016 0z" />,
      MessageSquare: (p) => <Icon {...p} d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z" />,
      FileText: (p) => <Icon {...p} d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z M14 2v6h6 M16 13H8 M16 17H8 M10 9H8" />,
      Send: (p) => <Icon {...p} d="M22 2L11 13 M22 2l-7 20-4-9-9-4 20-7z" />,
      Upload: (p) => <Icon {...p} d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4 M17 8l-5-5-5 5 M12 3v12" />,
      Copy: (p) => <Icon {...p} d="M20 9h-9a2 2 0 00-2 2v9a2 2 0 002 2h9a2 2 0 002-2v-9a2 2 0 00-2-2z M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1" />,
      Check: (p) => <Icon {...p} d="M20 6L9 17l-5-5" />,
      X: (p) => <Icon {...p} d="M18 6L6 18 M6 6l12 12" />,
      RefreshCw: (p) => <Icon {...p} d="M23 4v6h-6 M1 20v-6h6 M3.51 9a9 9 0 0114.85-3.36L23 10 M1 14l4.64 4.36A9 9 0 0020.49 15" />,
      Server: (p) => <Icon {...p} d="M2 9h20M2 15h20M4 5h16a2 2 0 012 2v10a2 2 0 01-2 2H4a2 2 0 01-2-2V7a2 2 0 012-2z M6 12h.01" />,
    };

    function App() {
      const [mode, setMode] = useState('chat');
      const [sourceLang, setSourceLang] = useState('en');
      const [targetLang, setTargetLang] = useState('zh');
      const [inputText, setInputText] = useState('');
      const [outputText, setOutputText] = useState('');
      const [isLoading, setIsLoading] = useState(false);
      const [copied, setCopied] = useState(false);
      const [uploadedFile, setUploadedFile] = useState(null);
      const [chatHistory, setChatHistory] = useState([]);
      const [showSettings, setShowSettings] = useState(false);
      const ollamaUrl = 'http://10.6.101.7:11434';
      const [models, setModels] = useState([]);
      const [selectedModel, setSelectedModel] = useState('');
      const [loadingModels, setLoadingModels] = useState(false);
      const [connectionStatus, setConnectionStatus] = useState('idle');
      const [connectionError, setConnectionError] = useState('');
      const [customPrompt, setCustomPrompt] = useState('');
      const [testingModel, setTestingModel] = useState(false);
      const [testResult, setTestResult] = useState(null);
      const [streaming, setStreaming] = useState(true);
      const [history, setHistory] = useState([]);
      const [showHistory, setShowHistory] = useState(false);
      const fileInputRef = useRef(null);
      const chatEndRef = useRef(null);

      const languages = [
        { code: 'en', name: 'English', native: 'English' },
        { code: 'zh', name: '中文', native: 'Chinese' },
        { code: 'ja', name: '日本語', native: 'Japanese' },
        { code: 'ko', name: '한국어', native: 'Korean' },
        { code: 'de', name: 'Deutsch', native: 'German' },
        { code: 'fr', name: 'Français', native: 'French' },
        { code: 'es', name: 'Español', native: 'Spanish' },
        { code: 'pt', name: 'Português', native: 'Portuguese' },
        { code: 'ru', name: 'Русский', native: 'Russian' },
        { code: 'ar', name: 'العربية', native: 'Arabic' },
        { code: 'it', name: 'Italiano', native: 'Italian' },
        { code: 'vi', name: 'Tiếng Việt', native: 'Vietnamese' },
        { code: 'th', name: 'ไทย', native: 'Thai' },
      ];

      const defaultPrompts = {
        'chat': `You are a professional translator. Translate the following {source} text into {target} for natural everyday conversation. Only output the translation:\n\n{text}`,
        'contract': `You are a professional legal translator. Translate the following {source} document into formal, accurate {target}. Preserve structure, numbering, terms, and formatting. Only output the translation:\n\n{text}`,
      };

      const [promptTemplate, setPromptTemplate] = useState('chat');

      useEffect(() => {
        chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [chatHistory]);

      useEffect(() => {
        try {
          const raw = localStorage.getItem('translateHistory');
          if (raw) setHistory(JSON.parse(raw));
        } catch {}
      }, []);

      const persistHistory = (items) => {
        setHistory(items);
        try {
          localStorage.setItem('translateHistory', JSON.stringify(items));
        } catch {}
      };

      const addHistoryItem = (item) => {
        setHistory(prev => {
          const next = [item, ...prev].slice(0, 50);
          try {
            localStorage.setItem('translateHistory', JSON.stringify(next));
          } catch {}
          return next;
        });
      };

      const clearHistory = () => {
        persistHistory([]);
      };

      const restoreHistoryItem = (item) => {
        setMode(item.mode);
        setSourceLang(item.sourceLang);
        setTargetLang(item.targetLang);
        setSelectedModel(item.model || selectedModel);
        setInputText(item.input || '');
        if (item.mode === 'document') setOutputText(item.output || '');
      };

      useEffect(() => {
        setPromptTemplate(mode === 'chat' ? 'chat' : 'contract');
        setCustomPrompt('');
      }, [mode]);

      const fetchModels = async () => {
        setLoadingModels(true);
        try {
          const res = await fetch(`${ollamaUrl}/api/tags`);
          if (!res.ok) {
            const text = await res.text();
            throw new Error(`HTTP ${res.status}: ${text}`);
          }
          const data = await res.json();
          setModels(data.models || []);
          setConnectionStatus((data.models || []).length > 0 ? 'ok' : 'empty');
          setConnectionError('');
          if (data.models?.length > 0 && !selectedModel) {
            const gemma = data.models.find(m => m.name.includes('gemma'));
            setSelectedModel(gemma?.name || data.models[0].name);
          }
        } catch (e) {
          console.error('Failed to fetch models:', e);
          setModels([]);
          setConnectionStatus('error');
          setConnectionError(e.message || '连接失败');
        }
        setLoadingModels(false);
      };

      useEffect(() => { fetchModels(); }, []);

      const getLangName = (code, type = 'native') => {
        const lang = languages.find(l => l.code === code);
        return type === 'native' ? lang?.native : lang?.name;
      };

      const buildPrompt = (text) => {
        const template = customPrompt || defaultPrompts[promptTemplate] || defaultPrompts['chat'];
        return template
          .replace('{source}', getLangName(sourceLang))
          .replace('{target}', getLangName(targetLang))
          .replace('{targetCode}', targetLang)
          .replace('{text}', text);
      };

      const callOllamaStream = async (prompt, onChunk, onDone) => {
        const res = await fetch(`${ollamaUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            model: selectedModel,
            messages: [{ role: 'user', content: prompt }],
            stream: true,
          }),
        });
        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let fullText = '';
        let buffer = '';
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';
          for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed.startsWith('data:')) continue;
            const data = trimmed.slice(5).trim();
            if (data === '[DONE]') {
              onDone(fullText);
              return;
            }
            try {
              const json = JSON.parse(data);
              const delta = json.choices?.[0]?.delta?.content || '';
              if (delta) {
                fullText += delta;
                onChunk(fullText);
              }
            } catch {}
          }
        }
        onDone(fullText);
      };

      const callOllama = async (prompt) => {
        const res = await fetch(`${ollamaUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            model: selectedModel,
            messages: [{ role: 'user', content: prompt }],
            stream: false,
          }),
        });
        const data = await res.json();
        return data.choices?.[0]?.message?.content ?? '';
      };

      const testOpenAIConnection = async () => {
        if (!selectedModel?.trim()) return;
        setTestingModel(true);
        setTestResult(null);
        try {
          const res = await fetch(`${ollamaUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              model: selectedModel,
              messages: [{ role: 'user', content: 'ping' }],
              stream: false,
            }),
          });
          if (!res.ok) {
            const text = await res.text();
            throw new Error(`HTTP ${res.status}: ${text}`);
          }
          const data = await res.json();
          const content = data.choices?.[0]?.message?.content ?? '';
          setTestResult({ ok: true, message: content ? '接口可用' : '接口可用（无返回内容）' });
        } catch (e) {
          setTestResult({ ok: false, message: e.message || '连接失败' });
        }
        setTestingModel(false);
      };

      const swapLanguages = () => {
        setSourceLang(targetLang);
        setTargetLang(sourceLang);
      };

      const handleTranslate = async () => {
        if (!inputText.trim() || !selectedModel) return;
        setIsLoading(true);
        setOutputText('');
        try {
          const prompt = buildPrompt(inputText);
          if (streaming) {
            await callOllamaStream(
              prompt,
              (text) => setOutputText(text),
              (fullText) => {
                setIsLoading(false);
                addHistoryItem({
                  id: Date.now(),
                  mode,
                  sourceLang,
                  targetLang,
                  model: selectedModel,
                  input: inputText,
                  output: fullText,
                  timestamp: new Date().toISOString(),
                });
              }
            );
          } else {
            const result = await callOllama(prompt);
            setOutputText(result);
            setIsLoading(false);
            addHistoryItem({
              id: Date.now(),
              mode,
              sourceLang,
              targetLang,
              model: selectedModel,
              input: inputText,
              output: result,
              timestamp: new Date().toISOString(),
            });
          }
        } catch (e) {
          setOutputText(`错误: ${e.message}\n\n请检查:\n1. Ollama 是否运行: ollama serve\n2. 是否允许跨域: OLLAMA_ORIGINS="*" ollama serve`);
          setIsLoading(false);
        }
      };

      const handleChatSubmit = async () => {
        if (!inputText.trim() || !selectedModel) return;
        const userMsg = { role: 'user', content: inputText, lang: sourceLang };
        setChatHistory(prev => [...prev, userMsg]);
        const textToTranslate = inputText;
        setInputText('');
        setIsLoading(true);

        const assistantMsg = { role: 'assistant', content: '', lang: targetLang, model: selectedModel };
        setChatHistory(prev => [...prev, assistantMsg]);

        try {
          const prompt = buildPrompt(textToTranslate);
          if (streaming) {
            await callOllamaStream(
              prompt,
              (text) => setChatHistory(prev => {
                const updated = [...prev];
                updated[updated.length - 1] = { ...updated[updated.length - 1], content: text };
                return updated;
              }),
              (fullText) => {
                setIsLoading(false);
                addHistoryItem({
                  id: Date.now(),
                  mode,
                  sourceLang,
                  targetLang,
                  model: selectedModel,
                  input: textToTranslate,
                  output: fullText,
                  timestamp: new Date().toISOString(),
                });
              }
            );
          } else {
            const result = await callOllama(prompt);
            setChatHistory(prev => {
              const updated = [...prev];
              updated[updated.length - 1] = { ...updated[updated.length - 1], content: result };
              return updated;
            });
            setIsLoading(false);
            addHistoryItem({
              id: Date.now(),
              mode,
              sourceLang,
              targetLang,
              model: selectedModel,
              input: textToTranslate,
              output: result,
              timestamp: new Date().toISOString(),
            });
          }
        } catch (e) {
          setChatHistory(prev => {
            const updated = [...prev];
            updated[updated.length - 1] = { ...updated[updated.length - 1], content: `错误: ${e.message}`, error: true };
            return updated;
          });
          setIsLoading(false);
        }
      };

      const extractPdfText = async (file) => {
        const arrayBuffer = await file.arrayBuffer();
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        let text = '';
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const content = await page.getTextContent();
          text += content.items.map(item => item.str).join(' ') + '\n\n';
        }
        return text.trim();
      };

      const extractDocxText = async (file) => {
        const arrayBuffer = await file.arrayBuffer();
        const result = await mammoth.extractRawText({ arrayBuffer });
        return result.value;
      };

      const handleFileUpload = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        setUploadedFile(file);
        setIsLoading(true);
        
        try {
          const ext = file.name.split('.').pop().toLowerCase();
          let text = '';
          
          if (ext === 'pdf') {
            text = await extractPdfText(file);
          } else if (ext === 'doc' || ext === 'docx') {
            text = await extractDocxText(file);
          } else {
            // 纯文本文件
            text = await new Promise((resolve) => {
              const reader = new FileReader();
              reader.onload = (ev) => resolve(ev.target.result);
              reader.readAsText(file);
            });
          }
          
          setInputText(text);
        } catch (err) {
          setInputText(`文件解析失败: ${err.message}`);
        }
        setIsLoading(false);
      };

      const copyToClipboard = (text) => {
        navigator.clipboard.writeText(text || outputText);
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
      };

      const clearAll = () => {
        setInputText('');
        setOutputText('');
        setUploadedFile(null);
        setChatHistory([]);
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 text-white p-4">
          <div className="max-w-5xl mx-auto">
            {/* Header */}
            <div className="flex items-center justify-between mb-6">
              <div>
                <h1 className="text-2xl font-bold bg-gradient-to-r from-blue-400 to-emerald-400 bg-clip-text text-transparent flex items-center gap-2">
                  <Icons.Languages className="w-7 h-7 text-blue-400" />
                  Translate Tool
                </h1>
                <p className="text-slate-400 text-sm mt-1">本地多模型翻译工具</p>
              </div>
              <button onClick={() => setShowSettings(!showSettings)} className={`p-2.5 rounded-lg transition-colors ${showSettings ? 'bg-blue-600' : 'bg-slate-700/80 hover:bg-slate-700'}`}>
                <Icons.Settings className="w-5 h-5" />
              </button>
            </div>

            {/* Settings Panel */}
            {showSettings && (
              <div className="mb-6 p-4 bg-slate-800/70 rounded-xl border border-slate-700/50 space-y-4">
                <div className="flex items-center gap-2 text-sm font-medium text-slate-300 mb-3">
                  <Icons.Server className="w-4 h-4" />
                  Ollama 配置
                </div>
                <div className="grid md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-xs text-slate-400 mb-1.5">连接状态</label>
                    <div className="flex items-center gap-2">
                      {connectionStatus === 'ok' && (
                        <span className="text-emerald-400 text-sm">已连接</span>
                      )}
                      {connectionStatus === 'empty' && (
                        <span className="text-amber-400 text-sm">已连接（无模型）</span>
                      )}
                      {connectionStatus === 'error' && (
                        <span className="text-red-400 text-sm">连接失败：{connectionError}</span>
                      )}
                      {connectionStatus === 'idle' && (
                        <span className="text-slate-400 text-sm">未检查</span>
                      )}
                    </div>
                  </div>
                  <div>
                    <label className="block text-xs text-slate-400 mb-1.5">选择模型</label>
                    <div className="flex gap-2">
                      <select value={selectedModel} onChange={(e) => setSelectedModel(e.target.value)} className="flex-1 bg-slate-700/50 border border-slate-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        {models.length === 0 && <option value="">未找到模型</option>}
                        {models.map(m => <option key={m.name} value={m.name}>{m.name}</option>)}
                      </select>
                      <button onClick={fetchModels} disabled={loadingModels} className="px-3 bg-slate-700 hover:bg-slate-600 rounded-lg transition-colors">
                        <Icons.RefreshCw className={`w-4 h-4 ${loadingModels ? 'animate-spin' : ''}`} />
                      </button>
                      <button onClick={testOpenAIConnection} disabled={testingModel || !selectedModel?.trim()} className="px-3 bg-emerald-600/80 hover:bg-emerald-600 disabled:opacity-50 rounded-lg transition-colors text-sm">
                        {testingModel ? '测试中' : '测试接口'}
                      </button>
                    </div>
                    {testResult && (
                      <div className={`mt-2 text-xs ${testResult.ok ? 'text-emerald-400' : 'text-red-400'}`}>
                        {testResult.message}
                      </div>
                    )}
                  </div>
                </div>
                <div className="flex items-center gap-3">
                  <label className="flex items-center gap-2 text-sm text-slate-300 cursor-pointer">
                    <input type="checkbox" checked={streaming} onChange={(e) => setStreaming(e.target.checked)} className="w-4 h-4 rounded bg-slate-700 border-slate-600" />
                    流式输出（打字机效果）
                  </label>
                </div>
                <div>
                  <label className="block text-xs text-slate-400 mb-1.5">翻译场景</label>
                  <div className="text-sm text-slate-300">
                    {mode === 'chat' ? '常规对话翻译（流利自然）' : '合同等文件翻译（正式严谨）'}
                  </div>
                </div>
              </div>
            )}

            {/* Model Badge & Mode Toggle */}
            <div className="flex items-center justify-between mb-4">
              <div className="flex items-center gap-2">
                {connectionStatus === 'ok' && selectedModel && (
                  <span className="px-3 py-1 bg-emerald-600/20 text-emerald-400 text-xs rounded-full border border-emerald-600/30">
                    已连接模型：{selectedModel}
                  </span>
                )}
                {connectionStatus === 'empty' && (
                  <span className="px-3 py-1 bg-amber-600/20 text-amber-400 text-xs rounded-full border border-amber-600/30">已连接（无模型）</span>
                )}
                {connectionStatus === 'error' && (
                  <span className="px-3 py-1 bg-red-600/20 text-red-400 text-xs rounded-full border border-red-600/30">未连接 Ollama</span>
                )}
              </div>
              <div className="flex gap-1 bg-slate-800/50 p-1 rounded-lg">
                <button onClick={() => setMode('chat')} className={`flex items-center gap-1.5 px-4 py-2 text-sm rounded-md transition-all ${mode === 'chat' ? 'bg-slate-700 text-white' : 'text-slate-400 hover:text-white'}`}>
                  <Icons.MessageSquare className="w-4 h-4" />对话
                </button>
                <button onClick={() => setMode('document')} className={`flex items-center gap-1.5 px-4 py-2 text-sm rounded-md transition-all ${mode === 'document' ? 'bg-slate-700 text-white' : 'text-slate-400 hover:text-white'}`}>
                  <Icons.FileText className="w-4 h-4" />文档
                </button>
              </div>
            </div>

            {/* History */}
            <div className="mb-4">
              <div className="flex items-center justify-between">
                <button onClick={() => setShowHistory(!showHistory)} className="text-sm text-slate-300 hover:text-white">
                  历史记录 {showHistory ? '▲' : '▼'}
                </button>
                {history.length > 0 && (
                  <button onClick={clearHistory} className="text-xs text-slate-400 hover:text-red-400">清空</button>
                )}
              </div>
              {showHistory && (
                <div className="mt-2 max-h-40 overflow-auto border border-slate-700/50 rounded-lg">
                  {history.length === 0 && (
                    <div className="px-3 py-2 text-xs text-slate-500">暂无记录</div>
                  )}
                  {history.map(item => (
                    <div key={item.id} className="px-3 py-2 text-xs text-slate-300 border-b border-slate-700/40 hover:bg-slate-800/50 cursor-pointer" onClick={() => restoreHistoryItem(item)}>
                      <div className="flex items-center gap-2">
                        <span className="text-slate-400">{item.mode === 'chat' ? '对话' : '文档'}</span>
                        <span>{item.sourceLang} → {item.targetLang}</span>
                        {item.model && <span className="text-emerald-400">{item.model}</span>}
                      </div>
                      <div className="text-slate-500 truncate">{item.input}</div>
                    </div>
                  ))}
                </div>
              )}
            </div>

            {/* Language Selector */}
            <div className="flex items-center justify-center gap-3 mb-5">
              <select value={sourceLang} onChange={(e) => setSourceLang(e.target.value)} className="bg-slate-700/80 border border-slate-600 rounded-lg px-4 py-2.5 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                {languages.map(l => <option key={l.code} value={l.code}>{l.name}</option>)}
              </select>
              <button onClick={swapLanguages} className="p-2.5 bg-slate-700/80 rounded-lg hover:bg-slate-600 transition-colors">
                <Icons.RefreshCw className="w-4 h-4" />
              </button>
              <select value={targetLang} onChange={(e) => setTargetLang(e.target.value)} className="bg-slate-700/80 border border-slate-600 rounded-lg px-4 py-2.5 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                {languages.map(l => <option key={l.code} value={l.code}>{l.name}</option>)}
              </select>
            </div>

            {mode === 'chat' ? (
              <div className="bg-slate-800/50 rounded-2xl border border-slate-700/50 overflow-hidden">
                <div className="h-80 overflow-y-auto p-4 space-y-3">
                  {chatHistory.length === 0 && (
                    <div className="text-center text-slate-500 py-16">
                      <Icons.MessageSquare className="w-12 h-12 mx-auto mb-3 opacity-50" />
                      <p>输入文本开始翻译对话</p>
                    </div>
                  )}
                  {chatHistory.map((msg, i) => (
                    <div key={i} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                      <div className={`max-w-[80%] px-4 py-2.5 rounded-2xl ${msg.role === 'user' ? 'bg-blue-600 rounded-br-md' : msg.error ? 'bg-red-900/50 rounded-bl-md' : 'bg-slate-700 rounded-bl-md'}`}>
                        <div className="flex items-center gap-2 mb-1">
                          <span className="text-xs text-slate-300">{msg.role === 'user' ? `原文 (${msg.lang})` : `翻译 (${msg.lang})`}</span>
                          {msg.model && <span className="text-xs text-slate-500">{msg.model}</span>}
                        </div>
                        <p className="text-sm whitespace-pre-wrap">{msg.content || (isLoading && i === chatHistory.length - 1 ? '...' : '')}</p>
                      </div>
                    </div>
                  ))}
                  <div ref={chatEndRef} />
                </div>
                <div className="border-t border-slate-700/50 p-4">
                  <div className="flex gap-3">
                    <textarea value={inputText} onChange={(e) => setInputText(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && !e.shiftKey && (e.preventDefault(), handleChatSubmit())} placeholder="输入要翻译的文本..." className="flex-1 bg-slate-700/50 border border-slate-600 rounded-xl px-4 py-3 text-sm resize-none focus:outline-none focus:ring-2 focus:ring-blue-500 placeholder-slate-500" rows={2} />
                    <button onClick={handleChatSubmit} disabled={!inputText.trim() || isLoading || !selectedModel} className="px-5 bg-blue-600 hover:bg-blue-500 disabled:bg-slate-700 disabled:text-slate-500 rounded-xl transition-colors">
                      <Icons.Send className="w-4 h-4" />
                    </button>
                  </div>
                </div>
              </div>
            ) : (
              <div className="grid md:grid-cols-2 gap-4">
                <div className="bg-slate-800/50 rounded-2xl border border-slate-700/50 overflow-hidden">
                  <div className="flex items-center justify-between px-4 py-3 border-b border-slate-700/50">
                    <span className="text-sm font-medium text-slate-300">原文</span>
                    <div className="flex gap-2">
                      <input type="file" ref={fileInputRef} onChange={handleFileUpload} accept=".txt,.md,.json,.csv,.srt,.vtt,.pdf,.doc,.docx" className="hidden" />
                      <button onClick={() => fileInputRef.current.click()} className="flex items-center gap-1.5 px-3 py-1.5 text-xs bg-slate-700 hover:bg-slate-600 rounded-lg transition-colors">
                        <Icons.Upload className="w-3.5 h-3.5" />上传
                      </button>
                      {(inputText || uploadedFile) && (
                        <button onClick={clearAll} className="p-1.5 text-slate-400 hover:text-white rounded-lg transition-colors">
                          <Icons.X className="w-4 h-4" />
                        </button>
                      )}
                    </div>
                  </div>
                  {uploadedFile && (
                    <div className="px-4 py-2 bg-slate-700/30 border-b border-slate-700/50 flex items-center gap-2 text-sm text-slate-300">
                      <Icons.FileText className="w-4 h-4" />{uploadedFile.name}
                    </div>
                  )}
                  <textarea value={inputText} onChange={(e) => setInputText(e.target.value)} placeholder="粘贴文本或上传文档..." className="w-full h-64 bg-transparent p-4 text-sm resize-none focus:outline-none placeholder-slate-500" />
                  <div className="px-4 py-3 border-t border-slate-700/50">
                    <button onClick={handleTranslate} disabled={!inputText.trim() || isLoading || !selectedModel} className="w-full py-2.5 bg-blue-600 hover:bg-blue-500 disabled:bg-slate-700 disabled:text-slate-500 rounded-xl font-medium transition-colors flex items-center justify-center gap-2">
                      {isLoading ? <><Icons.RefreshCw className="w-4 h-4 animate-spin" />翻译中...</> : <><Icons.Languages className="w-4 h-4" />开始翻译</>}
                    </button>
                  </div>
                </div>
                <div className="bg-slate-800/50 rounded-2xl border border-slate-700/50 overflow-hidden">
                  <div className="flex items-center justify-between px-4 py-3 border-b border-slate-700/50">
                    <span className="text-sm font-medium text-slate-300">译文</span>
                    {outputText && (
                      <button onClick={() => copyToClipboard()} className="flex items-center gap-1.5 px-3 py-1.5 text-xs bg-slate-700 hover:bg-slate-600 rounded-lg transition-colors">
                        {copied ? <Icons.Check className="w-3.5 h-3.5 text-green-400" /> : <Icons.Copy className="w-3.5 h-3.5" />}
                        {copied ? '已复制' : '复制'}
                      </button>
                    )}
                  </div>
                  <div className="h-72 overflow-y-auto p-4">
                    {outputText ? <p className="text-sm whitespace-pre-wrap">{outputText}</p> : <div className="h-full flex items-center justify-center text-slate-500"><p>译文将在这里显示</p></div>}
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
